#include "bronnect.h"
#include "telex_block_flow.h"
#include "httpd.h"

#include <openssl/ssl.h>
#include <openssl/err.h>  // For ERR_print_errors.
#include "client.h"
#include "ssl_api.h"
#include "../util/telex_util.h"
#include "watchdog.h"

#include <sys/ioctl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#ifndef UNIX_PATH_MAX
#define UNIX_PATH_MAX 108 /* stupid un.h */
#endif

#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <fcntl.h>
#include <signal.h>

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <event.h>
#include <glib.h>

#include <linux/tcp_sk_forge.h>

GHashTable *connections;
char *service_host;
FILE *logfile;
int nclients = 0;


// Return 1 on success, 0 otherwise.
static int recv_msg_header(int conn, struct bro_record_hdr *hdr, int waitall) {
  assert(hdr);
  int status = recv(conn, hdr, sizeof(*hdr), waitall ? MSG_WAITALL : 0);
  if (status < sizeof(*hdr)) {
    if (status < 0) {
      perror("Couldn't receive message");
    } else if (status != 0) {
      fprintf(stderr, "Packet not of size bro_record size (status: %d)\n", status);
    }
    return 0;
  }
  return 1;
}

static int recv_init_data(int conn, struct bro_init_data *data, int waitall) {
  // TODO(swolchok): This function and recv_msg_header could be
  // generated by a macro.
  assert(data);
  int status = recv(conn, data, sizeof(*data), waitall ? MSG_WAITALL : 0);
  if (status < sizeof(*data)) {
    if (status < 0) {
      perror("Couldn't receive init data");
    }
    fprintf(stderr, "Packet not of size bro_init_data\n");
    return 0;
  }
  return 1;
}

int forward_client_to_service(struct ConnectionState *st) {
  char buf[4096];
  int r = 1;
  int ret = SSL_read(st->ssl, buf, sizeof(buf));
  int err = SSL_get_error(st->ssl, ret);
  switch (err) {
  case SSL_ERROR_NONE:
  {
//    fcntl(st->service_conn, F_SETFL, 0);
    assert(ret > 0);
    stats.up_bytes += ret;
    int status = sendall(st->service_conn, buf, ret);
    log_data(st, buf, ret);
    if (status < 0) {
      fprintf(stderr, "couldn't forward data to service\n");
      cleanup_connection(st);
      return 0;
    }
//    fcntl(st->service_conn, F_SETFL, O_NONBLOCK);
    break;
  }
  case SSL_ERROR_ZERO_RETURN:
  case SSL_ERROR_WANT_CONNECT:
  case SSL_ERROR_WANT_ACCEPT:
  case SSL_ERROR_WANT_X509_LOOKUP:
  case SSL_ERROR_SYSCALL:
  case SSL_ERROR_SSL:
    if (err == SSL_ERROR_SSL) {
      extern BIO *bio_err;
      if (!bio_err) {
        bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
      }
      ERR_print_errors(bio_err);
    } else if (err == SSL_ERROR_SYSCALL) {
        // Socket closed
        cleanup_connection_after_ssl(st, 1);
        return 0;
    }
    cleanup_connection(st);
    r = 0;
    break;
  case SSL_ERROR_WANT_READ:
  case SSL_ERROR_WANT_WRITE:
    //fprintf(stderr, "Ignoring recoverable SSL error %d while forwarding to service\n", err);
    break;
  }

  return r;
}

int forward_service_to_client(struct ConnectionState *st) {
  assert(st->client_conn >= 0);

  int conn = st->service_conn;
  int r = 1;
  char buf[4096];
  int num_received = recv(conn, buf, sizeof(buf), 0);
  if (num_received < 0) {
    perror("Error reading from service");
    if (errno == EAGAIN || errno == EWOULDBLOCK) {
      fprintf(stderr, "on_service_read called, but we'd block\n");
      return r;
    }

    cleanup_connection(st);
    r = 0;
    return r;
  } else if (num_received == 0) {
    cleanup_connection(st);
    r = 0;
    return r;
  }
  stats.down_bytes += num_received;

  // TODO(swolchok): some error codes are non-fatal...
  int ret = SSL_write(st->ssl, buf, num_received);
  int err = SSL_get_error(st->ssl, ret);
  switch (err) {
  case SSL_ERROR_NONE:
    break;
  case SSL_ERROR_WANT_WRITE:
  case SSL_ERROR_WANT_READ:
    //fprintf(stderr, "Recoverable SSL error %d writing to client", err);
    break;
  default:
    fprintf(stderr, "SSL error %d writing to client\n", err);
    cleanup_connection(st);
    r = 0;
    break;
  }

  return r;
}

static void try_to_forward(struct ConnectionState *st) {
  st->t_last_data = time(NULL);
  if (st->service_ready[READ] && st->client_ready[WRITE]) {
    if (!forward_service_to_client(st)) {
      // Failed, connection's cleaned up.
      //fprintf(stderr,"forward_service_to_client %p failed\n", st);
      return;
    }
    st->service_ready[READ] = st->client_ready[WRITE] = 0;
    event_add(st->ev_service_read, NULL);
    event_add(st->ev_client_write, NULL);
  }

  if (st->service_ready[WRITE] && st->client_ready[READ]) {
    if (!forward_client_to_service(st)) {
      // Failed, connection's cleaned up.
      //fprintf(stderr,"forward_client_to_service %p failed\n", st);
      return;
    }
    st->service_ready[WRITE] = st->client_ready[READ] = 0;
    event_add(st->ev_service_write, NULL);
    event_add(st->ev_client_read, NULL);
  }
}

static void on_read_ready(int fd, short event_type, struct ConnectionState *st) {
  assert(event_type == EV_READ);
  if (st->client_conn == fd) {
    st->client_ready[READ] = 1;
    event_del(st->ev_client_read);

    if (st->cleanup_waiting == SSL_ERROR_WANT_READ) {
      cleanup_connection_ssl_try_shutdown(st);
      return;
    } 

//    g_slice_free(st->ev_client_read);
//    st->ev_client_read = 0;
  } else if (st->service_conn == fd) {
    st->service_ready[READ] = 1;
    event_del(st->ev_service_read);
//    g_slice_free(st->ev_service_read);
//    st->ev_service_read = 0;
  } else {
    //fprintf(stderr,"Error: on_read_ready(%d, %d, %p)\n", fd, event_type, st);
    cleanup_connection(st);
    return;
  }

  try_to_forward(st);
  pet_watchdog(st);
}

static void on_write_ready(int fd, short event_type, struct ConnectionState *st) {
  assert(event_type == EV_WRITE);
  if (st->client_conn == fd) {
    if (st->cleanup_waiting == SSL_ERROR_WANT_WRITE) {
      cleanup_connection_ssl_try_shutdown(st);
      return;
    }
    st->client_ready[WRITE] = 1;
    event_del(st->ev_client_write);
  } else if (st->service_conn == fd) {
    st->service_ready[WRITE] = 1;
    event_del(st->ev_service_write);
  } else {    
    //fprintf(stderr,"Error: on_write_ready(%d, %d, %p)\n", fd, event_type, st);
    cleanup_connection(st);
    return;
  }

  try_to_forward(st);
  pet_watchdog(st);
}

// We have to both be connected to the client and the service before
// we register the event, hence this function.
static void setup_service_read(struct ConnectionState *st) {
  //if (st->ev_service_read == NULL) {
    // First time through. Allocate it as a signal.
    st->ev_service_read = g_slice_new(struct event);
    // Maintain invariant: ev_service_ready is event_added iff
    // it's not NULL and service_ready[READ] == 0.
  //  st->service_ready[READ] = 1;
  //} else {
    // Second time through.
    fcntl(st->service_conn, F_SETFL, O_NONBLOCK);
    event_set(st->ev_service_read, st->service_conn, EV_READ | EV_PERSIST,
              (void(*)(int, short, void*))on_read_ready, st);
    event_add(st->ev_service_read, NULL);
    st->service_ready[READ] = 0;
  //}
}

static void close_telex_connection(struct ConnectionState *st) {
  if (st->telex_conn >= 0) {
    close(st->telex_conn);
    st->telex_conn = -2;
  }
  if (st->ev_telex_read) {
    event_del(st->ev_telex_read);
    g_slice_free(struct event, st->ev_telex_read);
    st->ev_telex_read = NULL;
  }
}

static void setup_fake_socket(struct ConnectionState *st) {

    int fake_listen_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (fake_listen_sock == -1) {
      perror("creating socket for client connection");
      cleanup_connection(st);
      return;
    }

    struct sockaddr_in addr;
    addr.sin_family = AF_INET;
    addr.sin_port = st->flow_state.resp_p;
    addr.sin_addr.s_addr = st->flow_state.resp_h;

    int one = 1;
    setsockopt(fake_listen_sock, SOL_IP, IP_TRANSPARENT, &one, sizeof(one));
    setsockopt(fake_listen_sock, SOL_SOCKET, SO_REUSEADDR, &one, sizeof(one));

    if (bind(fake_listen_sock, (struct sockaddr *)&addr, sizeof(addr)) < 0) {
      perror("binding for client connection");
      close(fake_listen_sock);
      cleanup_connection(st);
      return;
    }

    struct sock_state s_st = {0};
    s_st.dport = st->flow_state.resp_p;
    s_st.daddr = st->flow_state.resp_h;
    s_st.saddr = st->flow_state.orig_h;
    s_st.sport = st->flow_state.orig_p;
    s_st.rcv_nxt = st->flow_state.tcp.ack;
    s_st.snd_nxt = st->flow_state.tcp.seq;
    s_st.snd_una = s_st.snd_nxt + 1;
    s_st.tstamp_ok = st->flow_state.tcp.option_ts ? 1 : 0;
    s_st.sack_ok = st->flow_state.tcp.option_sack ? 1 : 0;
    s_st.rcv_wnd = st->flow_state.tcp.rcv_window;
    s_st.snd_wnd = st->flow_state.tcp.snd_window;

    s_st.wscale_ok = 1;
    s_st.rcv_wscale = st->flow_state.tcp.rcv_window_scale;
    s_st.snd_wscale = st->flow_state.tcp.snd_window_scale;
    s_st.ts_recent = st->flow_state.tcp.cur_ts.tsecr;
    s_st.ts_val = st->flow_state.tcp.cur_ts.tsval;
    s_st.mss_clamp = 1460;
    s_st.ecn_ok = 0;
    if ((st->client_conn = ioctl(fake_listen_sock, 0xFACE, &s_st)) < 0) {
      perror("fake_accept_ioctl creating new connection");
      close(fake_listen_sock);
      cleanup_connection(st);
      return;
    }

    close(fake_listen_sock);

    setsockopt(st->client_conn, SOL_IP, IP_TRANSPARENT, &one, sizeof(one));
    fcntl(st->client_conn, F_SETFL, O_NONBLOCK);

    BIO *sock_bio = BIO_new_socket(st->client_conn, BIO_NOCLOSE);
    BIO_set_nbio(sock_bio, 1);

    SSL_set_bio(st->ssl, sock_bio, sock_bio);

    assert(!st->ev_client_read);
    st->ev_client_read = g_slice_new(struct event);
    event_set(st->ev_client_read, st->client_conn, EV_READ | EV_PERSIST,
              (void (*)(int, short, void*))on_read_ready, st);
    event_add(st->ev_client_read, NULL);

    assert(!st->ev_client_write);
    st->ev_client_write = g_slice_new(struct event);
    event_set(st->ev_client_write, st->client_conn, EV_WRITE | EV_PERSIST,
              (void (*)(int, short, void*))on_write_ready, st);
    event_add(st->ev_client_write, NULL);

}


void log_messageVA(const char *message, va_list args)
{
    struct timeval now;
    char timestamp[256];
    gettimeofday(&now, NULL);
    time_t sec = now.tv_sec;
    struct tm* ptm = localtime(&sec);
    strftime(timestamp, 20, "%b %d %H:%M:%S", ptm);
    fprintf(logfile, "%s.%03ld ",
        timestamp, now.tv_usec/1000);

    if (message) {
        vfprintf(logfile, message, args);
        fputs("\n", logfile);
    }
}

void log_message(const char *message, ...)
{
    va_list va; va_start(va, message);
    log_messageVA(message, va);
    va_end(va);
}

// this function will modify buf, you should send it off before
// this function is a hack, because all of the other hacks were less than successful
// ugh
// also, "security"
void log_data(struct ConnectionState *st, char *buf, int len)
{

    if (st->state == 3) {
        return;
    }
    st->state = 3;

    assert(len > 0);

    buf[len-1] = '\x00'; 
    char *line_break = strchr(buf, '\n');
    int line_len = len - 1;

    if (line_break) {
        line_len = (int)(line_break - buf);
    }

    if (line_len > 99) {
        line_len = 99;
    }

    
    assert(line_len >= 0);
    assert(line_len < len);
    
    buf[line_len] = '\x00'; // terminate string for printing
    
    // Log the client IP and service_conn local port
    int local_port = get_port(st->service_conn);
    struct in_addr x = {st->flow_state.orig_h};
    log_message("%s:%d -> %d key %d %s", 
        inet_ntoa(x),
        ntohs(st->flow_state.orig_p), local_port, st->key_port, buf);

}

int init_service_connection(int port, struct ConnectionState *st)
{
    int need_finish = 0;
    int service_conn = start_tcp_connect(service_host, port, &need_finish);
    if (service_conn < 0) {
      return service_conn;
    }  
    if (need_finish) {
      struct event *ev = st->ev_service_write = g_slice_new(struct event);
      event_set(ev, service_conn, EV_WRITE,
                (void (*)(int, short, void*))on_finish_connect, st);
      event_add(ev, NULL);
    } else {
      st->ev_service_write = NULL;
    }

    return service_conn;
}

void on_telex_read(int conn, short type, struct ConnectionState *st) {
  assert(type == EV_READ);
  if (st->telex_conn != conn) {
    fprintf(stderr, "on_telex_read: st->telex_conn = %d, conn = %d\n",
            st->telex_conn, conn);
  }
  if (st->state > 2) {
    return;
  } 
  //assert(st->telex_conn == conn);
  struct bro_record_hdr rec;
  int status = recv_msg_header(conn, &rec, 1);

  if (!status) {
    // want to shutdown silently here
    if (st->ssl) {
        SSL_free(st->ssl);
        st->ssl = NULL;
    }
    cleanup_connection_after_ssl(st, 1);
    return;
  }

  switch (rec.type) {
  case RECORD_TYPE_INIT:
  {
    struct bro_init_data init_data;
    assert(rec.len == sizeof(init_data));
    status = recv_init_data(conn, &init_data, 1);
    if (!status) {
      fprintf(stderr, "on_telex_read: recv_init_data returned 0\n");
      cleanup_connection(st);
      return;
    }

    st->state = 1;
    initialize_watchdog(st); // Longer timeout
    // Extra init data record; ignore it.
    if (st->client_conn >= 0) {
      fprintf(stderr, "Ignoring extra init data record (client %d)\n",
              st->cnum);
      return;
    }
    
    st->key_port = init_data.port;
    assert(st->key_port > 0);
    st->service_conn = init_service_connection(init_data.port, st);
    if (st->service_conn < 0) {
        fprintf(stderr, "Can't init service connection (client %d port %d)\n", 
               st->cnum, init_data.port);
        cleanup_connection(st);
        return;
    }
    if (st->service_conn == 0) {
        fprintf(stderr, "Warning: client %d got 0 for service conn (port %d)\n",
                st->cnum, get_port(st->service_conn));
    }

    st->flow_state = init_data.flow_state;
#ifdef TELEX_LEAK_KEY
    BIGNUM *client_priv;    
    BIGNUM *dh_p;
    //BIGNUM *dh_g;
    BIGNUM *srvr_pub_key;    
    char leaked_shared_secret[256];
    int leaked_len;

    dh_p = BN_bin2bn(init_data.dh.p, init_data.dh.p_len, NULL);
    //dh_g = BN_bin2bn(init_data.dh.g, init_data.dh.g_len, NULL);
    srvr_pub_key = BN_bin2bn(init_data.dh.pub_key, init_data.dh.pub_key_len, NULL);

    client_priv = telex_ssl_get_dh_key(&init_data.shared_secret, NULL);

    leaked_len = telex_get_shared_secret(client_priv, dh_p, 
                                        srvr_pub_key, leaked_shared_secret);  

    //These two are freed by telex_get_shared_secret
    //BN_free(dh_p);
    //BN_free(client_priv);
    BN_free(srvr_pub_key);

    if (leaked_len < 0) {
        fprintf(stderr, "on_telex_read: telex_get_shared_secret return -1\n");
        cleanup_connection(st);
        return;
    }

    st->ssl = get_live_ssl_obj(leaked_shared_secret, leaked_len, init_data.dh.client_random, init_data.dh.server_random, 1);

    memcpy(st->ssl->enc_read_ctx->iv, init_data.dh.client_iv, 16);
    memcpy(st->ssl->enc_write_ctx->iv, init_data.dh.server_iv, 16);

#if 0
    printf("\nleaked len: %d\n", leaked_len);
    hexdump(leaked_shared_secret, leaked_len);
    
    printf("\nclient random:\n");
    hexdump(init_data.dh.client_random, 32);
    
    printf("\nserver random:\n");
    hexdump(init_data.dh.server_random, 32);
    printf("\n\n");

    printf("\nread_mac_secret:\n");
    hexdump(st->ssl->s3->read_mac_secret, 20);
    printf("\nwrite_mac_secret:\n");
    hexdump(st->ssl->s3->write_mac_secret, 20);
    printf("\nwrite_ctx_oiv:\n");
    hexdump(st->ssl->enc_write_ctx->oiv, 16);
    printf("\nwrite_ctx_iv:\n");
    hexdump(st->ssl->enc_write_ctx->iv, 16);
    printf("\nread_ctx_oiv:\n");
    hexdump(st->ssl->enc_read_ctx->oiv, 16);
    printf("\nread_ctx_iv:\n");
    hexdump(st->ssl->enc_read_ctx->iv, 16); 
    printf("\nssl->enc_read_ctx->iv %p\n", st->ssl->enc_read_ctx->iv);
#endif

#else

    st->ssl = get_live_ssl_obj(&init_data.shared_secret, sizeof(init_data.shared_secret),
                               1);
#endif

    break;
  }
  case RECORD_TYPE_RAW_PKT:
  {
    // Current semantics: forward the raw packet.
    struct iphdr *iph = g_malloc(rec.len);
    //printf("raw_pkt size %d, iph %p\n", rec.len, iph);

    if (st->state != 1) {
      fprintf(stderr, "Warning: received raw packet in state %d (2 expected)\n",
              st->state);
      cleanup_connection(st);
      return;
    }
    st->state = 2;
    int num_received = recv(conn, iph, rec.len, MSG_WAITALL);
    //printf("conn %d got %d bytes\n", conn, num_received);
    if (num_received != rec.len) {
      fprintf(stderr, "couldn't receive raw packet\n");
      g_free(iph);
      cleanup_connection(st);
      return;
    }
    
    setup_fake_socket(st);

    struct tcphdr *tcph = IP_TCP(iph);
    char *pkt_data = TCP_DATA(tcph); // TODO: optimize and only have
                                     // bro send the data part of packet.
    int pkt_len = rec.len - (pkt_data - (char *)iph);

    int status = sendall(st->client_conn, pkt_data, pkt_len);
    if (status < 0) {
      fprintf(stderr, "Error: fwd finish message to client %d (port %d)\n",
                    st->cnum, ntohs(st->flow_state.orig_p));
    }

    close_telex_connection(st);
    // Remove the following when enabling the #if 0ed code:
    g_free(iph);
    break;
  }

  default:
    fprintf(stderr, "undefined bro record type: %d\n", rec.type);
    return;
  }
  pet_watchdog(st);
}

void cleanup_connection_after_ssl(struct ConnectionState *st, int unblock) {
  struct in_addr addr1, addr2;
  st->state = 6; // should never see this
  if (st->ssl) {
    SSL_free(st->ssl);
    st->ssl = NULL;
  }

  gboolean was_in_there = g_hash_table_remove(connections, st);
  if (!was_in_there) {
    fprintf(stderr, "WARNING: removal from connection hash table failed.\n");
    fprintf(stderr, "I really should be aborting now, but you get a chance to debug.\n");
  }

  if (st->client_conn >= 0) {
    close(st->client_conn);
    st->client_conn = -1;
  }

  if (unblock) {
    // Unblock flow.
    addr1.s_addr = st->flow_state.orig_h;
    addr2.s_addr = st->flow_state.resp_h;
    telex_remote_mod_flow(&addr1, st->flow_state.orig_p,
                          &addr2, st->flow_state.resp_p,
                          AF_INET, 0);
  }

#ifdef WATCHDOG
  if (st->ev_watchdog) {
    event_del(st->ev_watchdog);
    g_slice_free(struct event, st->ev_watchdog);
    st->ev_watchdog = NULL;
  }
#endif

  if (st->ev_telex_read) {
    event_del(st->ev_telex_read);
    g_slice_free(struct event, st->ev_telex_read);
  }
  if (st->ev_service_read) {
    if (!st->service_ready[READ]) {
      event_del(st->ev_service_read);
    }
    g_slice_free(struct event, st->ev_service_read);
  }
  if (st->ev_service_write) {
    if (!st->service_ready[WRITE]) {
      event_del(st->ev_service_write);
    }
    g_slice_free(struct event, st->ev_service_write);
  }
  if (st->ev_client_read) {
    if (!st->client_ready[READ]) {
      event_del(st->ev_client_read);
    }
    g_slice_free(struct event, st->ev_client_read);
  }
  if (st->ev_client_write) {
    if (!st->client_ready[WRITE]) {
      event_del(st->ev_client_write);
    }
    g_slice_free(struct event, st->ev_client_write);
  }
  if (st->telex_conn >= 0) {
    close(st->telex_conn);
  }
  if (st->service_conn >= 0) {
    close(st->service_conn);
  }
  g_slice_free(struct ConnectionState, st);

  stats.active_connections--;
}

void cleanup_connection_ssl_try_shutdown(struct ConnectionState *st) {

  if (!st->ssl) {
    cleanup_connection_after_ssl(st, 1);
    return;
  }
  st->state = 5;

  int r = SSL_shutdown(st->ssl);
  if (r < 0) {
    r = SSL_get_error(st->ssl, r);
    st->cleanup_waiting = r;
    switch (r) {
      case SSL_ERROR_NONE:
        break;
      case SSL_ERROR_WANT_READ:
      case SSL_ERROR_WANT_WRITE:
        // Events still fire (not cleaned up, 
        // is this a valid assumption?), wait for next one.
        return;
        /* break; */ 
      default:
        //fprintf(stderr, "SSL error %d cleaning up client %d\n", r, st->cnum);
        if (r == SSL_ERROR_SSL) {
          extern BIO *bio_err;
          if (!bio_err) {
            bio_err=BIO_new_fp(stderr,BIO_NOCLOSE);
          }
          ERR_print_errors(bio_err);
        } else if (r == SSL_ERROR_SYSCALL) {
          //Socket closed
        }
        break;
    }
  }

  cleanup_connection_after_ssl(st, 1);
}

void cleanup_connection_ssl(struct ConnectionState *st) {
  st->t_cleanup = time(NULL);
  close_telex_connection(st);
  if (st->ssl) {
    int r = SSL_shutdown(st->ssl);
    if (!r) {
      cleanup_connection_ssl_try_shutdown(st);
    } else {
      SSL_free(st->ssl);
      st->ssl = NULL;
      cleanup_connection_after_ssl(st, 1);
    }
  } else {
    cleanup_connection_after_ssl(st, (st->state > 0));
  }
}

void cleanup_connection(struct ConnectionState *st) {
  cleanup_connection_ssl(st); 
}

static void print_connection(struct ConnectionState *st) {
  printf("State for connection %d:\n", st->cnum);
  printf("telex_conn: %d\tservice_conn: %d\tclient_conn: %d\n",
         st->telex_conn, st->service_conn, st->client_conn);
  printf("first telex record: %d\n", st->first_telex_record);
  printf("Flow:\n");
  struct in_addr tmp;
  tmp.s_addr = st->flow_state.orig_h;
  printf("Originator: %s:%d\n", inet_ntoa(tmp), ntohs(st->flow_state.orig_p));
  tmp.s_addr = st->flow_state.resp_h;
  printf("Responder: %s:%d\n", inet_ntoa(tmp), ntohs(st->flow_state.resp_p));
  printf("Client ready: %d %d\n", st->client_ready[0], st->client_ready[1]);
  printf("Service ready: %d %d\n", st->service_ready[0], st->service_ready[1]);
  printf("Cleanup waiting: %d\n", st->cleanup_waiting);
  printf("State: %d\n", st->state);
  puts("==========");
}

static void print_connection_wrapper(gpointer key, gpointer value,
                                     gpointer user_data) {
  print_connection(key);
}

static void print_all_connections(int junk) {
  g_hash_table_foreach(connections, print_connection_wrapper, NULL);
}

void on_finish_connect(int conn, short type, struct ConnectionState *st) {
  assert(conn == st->service_conn);
  int optval;
  socklen_t optlen = sizeof(optval);
  if (getsockopt(conn, SOL_SOCKET, SO_ERROR, &optval, &optlen) != 0) {
    perror("on_finish_connect getsockopt");
    exit(1);
  }

  if (optval != 0) {
    fprintf(stderr, "Error connecting: %s", strerror(optval));
    cleanup_connection(st);
    return;
  } else {
    setup_service_read(st);
  }

  event_set(st->ev_service_write, st->service_conn, EV_WRITE | EV_PERSIST,
            (void (*)(int, short, void*))on_write_ready, st);
  event_add(st->ev_service_write, NULL);
  pet_watchdog(st);
}

void handle_bro_connection(int conn)
{
    struct ConnectionState *st = g_slice_new(struct ConnectionState);
    
    memset(st, 0, sizeof(struct ConnectionState));
    st->cnum = nclients++;
    st->telex_conn = conn;
    st->ssl = NULL;
    st->client_ready[0] = st->client_ready[1] = 0;
    st->service_ready[0] = st->service_ready[1] = 0;
    st->cleanup_waiting = SSL_ERROR_NONE;

    g_hash_table_insert(connections, st, GINT_TO_POINTER(1));

    st->client_conn = -1;
    st->service_conn = -1;
    st->first_telex_record = 1;
    st->state = 0;
    st->key_port = -1;

    st->ev_telex_read = g_slice_new(struct event);
    event_set(st->ev_telex_read, conn, EV_READ | EV_PERSIST,
              (void(*)(int, short, void*))on_telex_read, st);
    event_add(st->ev_telex_read, NULL);

    st->ev_service_read = st->ev_service_write = NULL;
    st->ev_client_read = st->ev_client_write = NULL;

    initialize_watchdog(st);

    st->t_created = time(NULL); 

    stats.active_connections++;
    stats.total_connections++;
}

void print_usage(char *arg)
{
  fprintf(stderr, "Bronnect\n");
  fprintf(stderr, "Interface between Bro and service\n");
  fprintf(stderr, "Usage:\n");
  fprintf(stderr, "    %s service_ip [bro-bronnect-path [httpd_port]]\n", arg);
}

void on_accept_ready(int sock, short type, void *arg) {
  int conn;
  if ((conn = accept(sock, NULL, NULL)) == -1) {
    perror("Couldn't accept");
    return;
  }

  handle_bro_connection(conn); 
}

static void clean_shutdown(int n) {
  event_loopbreak();
}

int main(int argc, char *argv[])
{
    if (argc < 2 || argc > 4) {
        print_usage(argv[0]);
        return 1;
    }
    signal(SIGPIPE, SIG_IGN);

    service_host = argv[1];
    
    int httpd_port = 8080;
    if (argc == 4) {
        httpd_port = atoi(argv[3]);
    }

    int sock;
    if ((sock = socket(AF_UNIX, SOCK_STREAM, 0)) == -1) {
        perror("Couldn't create socket");
        return 2;
    }

    logfile = fopen("/var/log/telex/bronnect.log", "a");
    if (logfile == NULL) {
        perror("Couldn't open log");
        return 2;
    }

    struct sockaddr_un addr;
    addr.sun_family = AF_UNIX;
    strcpy(addr.sun_path, "/tmp/bro-bronnect");
    if (argc >= 3) {
        strncpy(addr.sun_path, argv[2], UNIX_PATH_MAX);
    }
     
    if (bind(sock, (struct sockaddr *)&addr, sizeof(addr)) == -1) {
        perror("Couldn't bind");
        return 2;
    }

    if (listen(sock, 3) == -1) {
        perror("Couldn't listen");
        return 2;
    }

    const char *err = 0;
    if (telex_connect_to_flow_blocker("10.4.0.1", "4501", &err) < 0 || err) {
      fprintf(stderr, "Couldn't connect to flow blocker, bye\n");
      return 3;
    }

    telex_tcp_init();
    event_init();
    httpd_init(httpd_port);

    connections = g_hash_table_new(NULL, NULL);

    struct sigaction act;
    act.sa_handler = clean_shutdown;
    sigaction(SIGINT, &act, NULL);
    sigaction(SIGTERM, &act, NULL);
    act.sa_handler = print_all_connections;
    sigaction(SIGUSR1, &act, NULL);
    struct event accept_event;
    event_set(&accept_event, sock, EV_READ | EV_PERSIST,
              (void(*)(int, short, void*)) on_accept_ready, NULL);
    event_add(&accept_event, NULL);
    event_dispatch();
    return 0; 
}
